"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const acorn_1 = require("acorn");
const acorn_jsx_1 = __importDefault(require("acorn-jsx"));
const JSXParser = acorn_1.Parser.extend(acorn_jsx_1.default());
function parse(content, options = {
    ecmaVersion: 2021,
    sourceType: 'module',
}) {
    const importList = [];
    const exportList = [];
    const { body } = JSXParser.parse(content, options);
    if (Array.isArray(body)) {
        body.forEach((node) => {
            if (node.type === 'ImportDeclaration') {
                const { specifiers, source } = node;
                const item = {
                    moduleName: source.value,
                    starImport: '',
                    defaultImport: '',
                    namedImports: [],
                    sideEffectOnly: false,
                };
                if (Array.isArray(specifiers) && specifiers.length) {
                    specifiers.forEach(({ type, local, imported }) => {
                        switch (type) {
                            case 'ImportNamespaceSpecifier':
                                item.starImport = local && local.name;
                                break;
                            case 'ImportDefaultSpecifier':
                                item.defaultImport = local && local.name;
                                break;
                            case 'ImportSpecifier':
                                item.namedImports.push({
                                    name: imported && imported.name,
                                    alias: local && local.name,
                                });
                                break;
                            default:
                                break;
                        }
                    });
                }
                else {
                    item.sideEffectOnly = true;
                }
                importList.push(item);
            }
            if (node.type === 'ExportNamedDeclaration') {
                const { declaration, specifiers, source } = node;
                if (declaration) {
                    switch (declaration.type) {
                        case 'VariableDeclaration':
                            declaration.declarations.forEach(({ id, init }) => {
                                exportList.push({
                                    type: declaration.type,
                                    moduleName: id.name,
                                    value: content.slice(init.start, init.end),
                                });
                            });
                            break;
                        case 'FunctionDeclaration':
                            exportList.push({
                                type: declaration.type,
                                moduleName: declaration.id.name,
                                value: content.slice(declaration.start, declaration.end),
                            });
                            break;
                        default:
                            break;
                    }
                }
                else if (specifiers.length && source) {
                    specifiers.forEach(({ type, exported }) => {
                        exportList.push({
                            type,
                            moduleName: exported.name,
                            value: source.value,
                        });
                    });
                }
            }
        });
    }
    return {
        imports: importList,
        exports: exportList,
    };
}
exports.default = parse;
